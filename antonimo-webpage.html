<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Antonimo Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            text-align: center;
            margin: 20px;
            position: relative;
            min-height: 100vh;
            background-color: white;
            overflow-x: hidden;
        }
        #game {
            max-width: 600px;
            margin: auto;
            background-color: #f7f7f7;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .inter-row {
            display: flex;
            align-items: center;
            margin: 8px auto;
            width: 90%;
            cursor: grab;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .inter-row:active {
            cursor: grabbing;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .intermediary {
            flex: 1;
            padding: 12px;
            background: white;
            position: relative;
            text-align: center;
            font-weight: 500;
        }
        .correct {
            color: #10b981; /* Emerald green for correct */
            font-weight: bold;
            margin-left: 10px;
            min-width: 150px;
            text-align: left;
            transition: color 0.3s;
        }
        .incorrect {
            color: #ef4444; /* Red for incorrect */
            font-weight: bold;
            margin-left: 10px;
            min-width: 150px;
            text-align: left;
            transition: color 0.3s;
        }
        .has-answer::before {
            content: '✓';
            color: #10b981;
            position: absolute;
            left: 5px;
            top: 5px;
            font-size: 1.2em;
            font-weight: bold;
        }
        button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            transform: translateY(-1px);
        }
        #result {
            font-weight: bold;
            margin-top: 15px;
        }
        #result.success {
            color: #059669; /* Darker green */
        }
        #result.failure {
            color: #dc2626; /* Darker red */
        }
        .text-4xl { font-size: 2.25rem; }
        .text-xl { font-size: 1.25rem; }
        .text-lg { font-size: 1.125rem; }
        .text-md { font-size: 1rem; }
    </style>
</head>
<body>

    <div id="game">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Antonimo Gradiente Challenge</h2>
        <div id="level-label" class="text-xl font-bold mb-2 text-indigo-600"></div>
        <h1 id="word-pair" class="text-4xl font-extrabold mb-4 text-gray-900"></h1>
        <p id="pos-label" class="text-lg text-gray-700 mb-2"></p>
        <p id="hint-label" class="text-md text-gray-500 mb-2"></p>
        
        <!-- NEW CLOZE EXAMPLE HINT ADDED HERE -->
        <p id="cloze-example-label" class="text-md text-gray-500 italic mb-4"></p>

        <div id="sortable" class="mb-4">
            <!-- Intermediary words go here -->
        </div>

        <div class="flex justify-center space-x-4">
            <button id="check-button" onclick="checkOrder()" class="bg-indigo-500 text-white hover:bg-indigo-600 active:bg-indigo-700">Check Order</button>
            <button id="next-button" onclick="nextLevel()" class="bg-gray-300 text-gray-800 hover:bg-gray-400 active:bg-gray-500" disabled>Next Level</button>
        </div>

        <div id="result" class="text-xl mt-4 h-8 flex items-center justify-center"></div>

        <div id="answers" class="mt-8 text-sm text-gray-600">
            <!-- Correct answers will appear here -->
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Globals (Mandatory use) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app = null;
        let db = null;
        let auth = null;
        let userId = null;
        
        // --- Game State Globals ---
        let gameData = [];
        let currentLevel = 0;
        let currentAnswers = [];

        // Utility to shuffle an array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        async function initializeFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase config not available. Running locally.");
                return;
            }
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // Sign in using custom token or anonymously
                await new Promise((resolve) => {
                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                            } catch (error) {
                                console.error("Custom Auth failed, signing in anonymously:", error);
                                await signInAnonymously(auth);
                                userId = auth.currentUser.uid;
                            }
                        } else {
                            await signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                        }
                        console.log("Authenticated with User ID:", userId);
                        resolve();
                    });
                });

                // Load user progress
                onSnapshot(doc(db, "artifacts", appId, "users", userId, "game_state", "antonimo"), (docSnapshot) => {
                    if (docSnapshot.exists()) {
                        const savedState = docSnapshot.data();
                        currentLevel = savedState.level || 0;
                        console.log("Progress loaded. Starting at level:", currentLevel + 1);
                    }
                    loadData();
                }, (error) => {
                    console.error("Error setting up progress listener:", error);
                    loadData(); // Load data even if snapshot fails
                });

            } catch (error) {
                console.error("Failed to initialize or sign in to Firebase:", error);
                loadData(); // Fallback to start game without persistence
            }
        }

        async function saveProgress() {
            if (!db || !userId) {
                console.warn("Database not initialized. Cannot save progress.");
                return;
            }
            try {
                await setDoc(doc(db, "artifacts", appId, "users", userId, "game_state", "antonimo"), {
                    level: currentLevel,
                    timestamp: new Date()
                }, { merge: true });
                console.log("Progress saved successfully.");
            } catch (e) {
                console.error("Error saving progress:", e);
            }
        }

        async function loadData() {
            const csvFilePath = 'game-data.csv';
            try {
                const response = await fetch(csvFilePath);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();

                const lines = csvText.split('\n').slice(1).filter(line => line.trim() !== ''); // Skip header and empty lines
                
                gameData = lines.map(line => {
                    const parts = line.split(',');
                    // **CRITICAL UPDATE**: Check for 6 parts now (for the new Cloze Example column)
                    if (parts.length < 6) {
                        console.warn("Skipping malformed row (expected 6 columns):", line);
                        return null; 
                    }
                    return {
                        pair: parts[0],
                        intermediaries: parts[1].split(';'),
                        pos: parts[2],
                        hint: parts[3],
                        clozeExample: parts[4], // New data field
                        gradType: parts[5]       // Shifted index
                    };
                }).filter(item => item !== null);

                if (gameData.length > 0) {
                    if (currentLevel >= gameData.length) {
                        currentLevel = 0; // Reset if all levels completed
                    }
                    startGame(gameData[currentLevel]);
                } else {
                    document.getElementById('result').innerText = "Error: No game data loaded.";
                }

            } catch (error) {
                console.error("Failed to load or parse CSV data:", error);
                document.getElementById('result').innerText = "Error loading game data.";
            }
        }

        window.startGame = function(data) {
            currentAnswers = data.intermediaries.map(word => word.trim());
            const shuffledIntermediaries = [...currentAnswers];
            shuffleArray(shuffledIntermediaries);

            document.getElementById('level-label').innerText = `Level ${currentLevel + 1} of ${gameData.length}`;
            document.getElementById('word-pair').innerText = data.pair.replace('-', ' - ');
            document.getElementById('pos-label').innerText = `Part of Speech: ${data.pos}`;
            document.getElementById('hint-label').innerText = `Hint: ${data.hint}`;
            
            // **CRITICAL UPDATE**: Display the new cloze example hint
            document.getElementById('cloze-example-label').innerText = `Example: ${data.clozeExample}`;


            const sortable = document.getElementById('sortable');
            sortable.innerHTML = '';
            document.getElementById('result').innerHTML = '';
            document.getElementById('answers').innerHTML = '';
            document.getElementById('check-button').disabled = false;
            document.getElementById('next-button').disabled = true;

            shuffledIntermediaries.forEach((word, index) => {
                const row = document.createElement('div');
                row.className = 'inter-row bg-white hover:bg-gray-50';
                row.setAttribute('draggable', 'true');
                row.dataset.originalIndex = index; // Store original shuffle position

                const intermediaryDiv = document.createElement('div');
                intermediaryDiv.className = 'intermediary';
                intermediaryDiv.innerText = word;
                
                // Add a small spacer to avoid text misalignment
                const spacer = document.createElement('div');
                spacer.className = 'correct'; 
                spacer.style.visibility = 'hidden';
                spacer.style.width = '160px'; 
                spacer.innerText = 'Spacer';

                row.appendChild(intermediaryDiv);
                row.appendChild(spacer);
                sortable.appendChild(row);
            });
        }

        window.checkOrder = function() {
            const sortable = document.getElementById('sortable');
            const currentOrder = Array.from(sortable.children).map(row => row.querySelector('.intermediary').innerText.trim());
            const resultElement = document.getElementById('result');
            const checkButton = document.getElementById('check-button');
            const nextButton = document.getElementById('next-button');
            
            let isCorrect = true;
            let firstMistakeIndex = -1;

            sortable.querySelectorAll('.inter-row').forEach((row, index) => {
                const word = row.querySelector('.intermediary').innerText.trim();
                const feedbackDiv = row.querySelector('.correct'); // Reuse the 'correct' div for feedback

                feedbackDiv.classList.remove('correct', 'incorrect');
                feedbackDiv.innerText = '';

                if (word === currentAnswers[index]) {
                    feedbackDiv.classList.add('correct');
                    feedbackDiv.innerText = '✓ Correct Position';
                } else {
                    if (isCorrect) firstMistakeIndex = index;
                    isCorrect = false;
                    feedbackDiv.classList.add('incorrect');
                    feedbackDiv.innerText = 'X Incorrect Position';
                }
            });

            if (isCorrect) {
                resultElement.innerText = "¡Felicidades! Orden correcto.";
                resultElement.classList.add('success');
                resultElement.classList.remove('failure');
                checkButton.disabled = true;
                nextButton.disabled = false;
                if (db && userId) saveProgress();
            } else {
                resultElement.innerText = "Sigue intentándolo. Hay errores.";
                resultElement.classList.add('failure');
                resultElement.classList.remove('success');
                checkButton.disabled = false;
                nextButton.disabled = true;
            }
        }

        window.nextLevel = function() {
            currentLevel++;
            if (currentLevel < gameData.length) {
                startGame(gameData[currentLevel]);
            } else {
                document.getElementById('game').innerHTML = '<h2 class="text-3xl font-bold text-indigo-600">¡Juego Completado!</h2><p class="mt-4 text-xl">Has dominado todos los gradientes. ¡Excelente trabajo!</p>';
                currentLevel = 0; // Prepare for next play
                if (db && userId) saveProgress();
            }
        }

        // --- Drag and Drop Logic ---
        const sortable = document.getElementById('sortable');
        let draggedItem = null;
        
        // Use event delegation on the parent container
        document.addEventListener('dragstart', (e) => {
            draggedItem = e.target.closest('.inter-row');
            if (draggedItem) {
                setTimeout(() => draggedItem.style.opacity = '0.5', 0);
            }
        });
        
        document.addEventListener('dragend', (e) => {
            if (draggedItem) {
                draggedItem.style.opacity = '1';
                draggedItem = null;
            }
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (draggedItem && e.target.closest('#sortable')) {
                const sortableContainer = e.target.closest('#sortable');
                const afterElement = getDragAfterElement(sortableContainer, e.clientY);
                if (afterElement == null) {
                    sortableContainer.appendChild(draggedItem);
                } else {
                    sortableContainer.insertBefore(draggedItem, afterElement);
                }
            }
        });
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.inter-row:not([style*="opacity: 0.5"])')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Start initialization
        if (firebaseConfig) {
            initializeFirebase();
        } else {
            loadData(); // Load data without Firebase for testing/local
        }
    </script>
</body>
</html>
