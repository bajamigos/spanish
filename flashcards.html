<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Antonimo Flashcards</title>
    <!-- Link external stylesheet you uploaded -->
    <link rel="stylesheet" href="styles.css">
    <style>
        /* Minimal critical overrides to guarantee layout if external CSS is missing */
        #flashcard { display:none; }
        #buttons { display:none; }
        .word-box { text-align:center; }
        .neighbor-word { color:#666; }
        #download-updated-csv { display:none; margin-top: 6px; }
        #migration-note { font-size: 0.9em; color: #666; margin-top:8px; }
    </style>
</head>
<body>
    <h1>Flashcards v.2025.10.26</h1>
    <p id="progress"></p>

    <div id="login-form">
        <input id="email" type="email" placeholder="Email">
        <input id="password" type="password" placeholder="Password">
        <button onclick="signup()">Sign Up</button>
        <button onclick="login()">Login</button>
        <div id="error" style="color: red;"></div>
    </div>

    <div id="flashcard" class="content-card">
        <div id="card-num"></div>
        <div id="front">
            <div class="word-box-container">
                <div id="lower-neighbor-box" class="word-box neighbor-word"></div>
                <div id="answer-box" class="word-box"></div>
                <div id="higher-neighbor-box" class="word-box neighbor-word"></div>
            </div>
            <div id="cloze-display" class="cloze-sentence"></div>
        </div>
    </div>

    <div id="buttons">
        <div id="rate">
            <button id="flipBtn" onclick="flip()">Show Answer</button>
            <button id="incorrectBtn" onclick="rate(false)">Incorrect</button>
            <button id="correctBtn" onclick="rate(true)">Correct</button>
        </div>
    </div>

    <pre id="ascii-stats"></pre>

    <div id="controls-footer" class="footer-card">
        <div id="settings">
            New cards/day: <input id="daily-limit" type="number" min="1" value="10">
            <button onclick="saveSettings()">Save</button>
        </div>
        <button id="logout" onclick="auth.signOut()">Logout</button>
        <div id="migration-note"></div>
        <button id="download-updated-csv" onclick="downloadUpdatedCSV()">Download CSV with CardIDs</button>
    </div>

    <img src="antonimo-logo.jpg" alt="Antonimo logo" class="logo-bg">

    <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore-compat.js"></script>

    <script>
    // --- Firebase config (unchanged) ---
    const firebaseConfig = {
        apiKey: "AIzaSyDJYgI-xgZAGj6780W8BqXS4thd8ODvfDA",
        authDomain: "antonimo-acbd9.firebaseapp.com",
        projectId: "antonimo-acbd9",
        storageBucket: "antonimo-acbd9.firebasestorage.app",
        messagingSenderId: "904238822187",
        appId: "1:904238822187:web:2c0488369954495f3b8b6e",
        measurementId: "G-GTP9X49KNP"
    };
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // Globals
    let uid = null;
    let cardData = {};         // user SRS data (by CardID)
    let userSettings = {};     // user settings doc
    let currentCard = null;    // {index, card}
    let isFlipped = false;
    let cards = [];            // array of card objects: { id, front, back, pair, englishBack }
    let scales = {};           // pair -> [ordered words]
    let englishMap = {};       // word -> english translation
    let csvRowsRaw = null;     // raw parsed CSV rows (for download update)
    let csvHeader = null;      // header array
    let csvHadCardIDs = false; // whether original CSV had CardID column
    let csvUpdatedWithIDs = false;

    // ---------- CSV parsing helpers ----------
    // Parse a CSV string into rows of arrays. Handles quoted fields and commas.
    function parseCSV(text) {
        const rows = [];
        const lines = text.replace(/\r\n/g, '\n').split('\n');
        for (let rawLine of lines) {
            if (rawLine.trim() === '') continue;
            const row = [];
            let i = 0;
            while (i < rawLine.length) {
                if (rawLine[i] === '"') {
                    // quoted field
                    i++;
                    let val = '';
                    while (i < rawLine.length) {
                        if (rawLine[i] === '"') {
                            if (rawLine[i+1] === '"') { val += '"'; i += 2; continue; }
                            i++;
                            break;
                        } else {
                            val += rawLine[i++];
                        }
                    }
                    // skip comma
                    if (rawLine[i] === ',') i++;
                    row.push(val);
                } else {
                    // unquoted field
                    let j = rawLine.indexOf(',', i);
                    if (j === -1) j = rawLine.length;
                    row.push(rawLine.slice(i, j));
                    i = j + 1;
                }
            }
            rows.push(row);
        }
        return rows;
    }

    // Build a CSV string from header + rows (array of arrays). Properly quote fields with commas/quotes.
    function buildCSVString(header, rows) {
        function quoteField(f) {
            if (f === null || f === undefined) f = '';
            f = String(f);
            if (f.includes('"')) f = f.replace(/"/g, '""');
            if (f.includes(',') || f.includes('"') || f.includes('\n')) {
                return `"${f}"`;
            } else {
                return f;
            }
        }
        const out = [];
        out.push(header.map(quoteField).join(','));
        for (const r of rows) {
            out.push(r.map(quoteField).join(','));
        }
        return out.join('\n');
    }

    // Generate a short unique CardID for a row, ensuring it doesn't collide with existing IDs
    function generateCardID(pair, word, existingIDs, suffixCounterStart=1) {
        // sanitize pair/word
        const p = (pair || 'GEN').toString().toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6);
        const w = (word || '').toString().toUpperCase().replace(/[^A-Z0-9]/g, '').slice(0,6);
        let base = p ? (p + (w ? '_' + w : '')) : (w || 'CARD');
        base = base.slice(0, 20);
        let candidate = base;
        let counter = suffixCounterStart;
        while (existingIDs.has(candidate)) {
            candidate = `${base}_${counter}`;
            counter++;
        }
        existingIDs.add(candidate);
        return candidate;
    }

    // ---------- Load CSV and build cards/scales ----------
    async function loadCSVAndBuild() {
        const resp = await fetch('flashcard-data.csv', {cache: "no-store"});
        if (!resp.ok) throw new Error('Could not fetch flashcard-data.csv (' + resp.status + ')');
        const text = await resp.text();
        const rows = parseCSV(text);
        if (!rows || rows.length < 1) throw new Error('CSV empty or malformed');
        csvRowsRaw = rows.slice(); // preserve raw rows for potential download later
        csvHeader = rows[0].map(h => h.trim());
        const headerMap = {};
        csvHeader.forEach((h,i) => headerMap[h.toLowerCase()] = i);
        // Find important columns (case-insensitive)
        const hasCardIDCol = ('cardid' in headerMap);
        csvHadCardIDs = hasCardIDCol;
        const pairIdx = headerMap['pair'] !== undefined ? headerMap['pair'] : null;
        const orderIdx = headerMap['order'] !== undefined ? headerMap['order'] : null;
        const wordIdx = headerMap['word'] !== undefined ? headerMap['word'] : null;
        const sentencesIdx = headerMap['sentences'] !== undefined ? headerMap['sentences'] : null;
        const englishIdx = headerMap['english'] !== undefined ? headerMap['english'] : null;
        const cardIdIdx = hasCardIDCol ? headerMap['cardid'] : null;

        // Build existingIDs set from CSV if present
        const existingIDs = new Set();
        if (hasCardIDCol) {
            for (let r=1; r<rows.length; r++) {
                const id = (rows[r][cardIdIdx] || '').toString().trim();
                if (id) existingIDs.add(id);
            }
        }

        // Build scales map and cards
        cards = [];
        scales = {};
        englishMap = {};
        // iterate rows in file order; create cards for any row with sentences containing blanks
        for (let r=1; r<rows.length; r++) {
            const row = rows[r];
            const pair = pairIdx !== null ? (row[pairIdx] || '').trim() : '';
            const order = orderIdx !== null ? (row[orderIdx] || '').trim() : '';
            const word = wordIdx !== null ? (row[wordIdx] || '').trim() : '';
            const sentencesRaw = sentencesIdx !== null ? (row[sentencesIdx] || '').trim() : '';
            const english = englishIdx !== null ? (row[englishIdx] || '').trim() : '';
            let cardid = cardIdIdx !== null ? (row[cardIdIdx] || '').trim() : '';

            // store english map
            if (word) englishMap[word] = english || '';

            // scales: place word by order if numeric, else push
            if (pair) {
                if (!(pair in scales)) scales[pair] = [];
                if (order !== '' && !isNaN(parseInt(order))) {
                    scales[pair][parseInt(order)] = word;
                } else {
                    scales[pair].push(word);
                }
            }

            // ensure card id exists - if not we'll generate later (but we can generate now)
            if (!cardid) {
                // generate a unique id
                cardid = generateCardID(pair || word || 'CARD', word || '', existingIDs);
                // mark that CSV will need updating
                csvUpdatedWithIDs = true;
                // if the CSV header didn't have CardID, we'll later add a column and populate these IDs
            }

            // split sentences by '|' into multiple cloze sentences (only keep ones with blanks)
            const parts = sentencesRaw.split('|').map(s=>s.trim()).filter(s=>s.length>0);
            for (const s of parts) {
                if (s.includes('_____') || s.includes('____') || s.includes('___')) {
                    cards.push({
                        id: cardid,
                        front: s,
                        back: word,
                        pair: pair,
                        englishBack: english || ''
                    });
                }
            }
        }

        // Normalize scales (remove empty holes)
        for (const p in scales) {
            scales[p] = scales[p].filter(Boolean);
        }

        // If CSV did not originally have a CardID column, or we filled missing IDs, prepare a downloadable updated CSV
        if (csvUpdatedWithIDs) {
            // create new rows to download: clone csvRowsRaw and insert CardID column if needed
            const rowsForDownload = csvRowsRaw.map(r => r.slice()); // deep-ish copy
            if (!csvHadCardIDs) {
                // add header
                rowsForDownload[0].push('CardID');
                // for each data row, compute id again the same way to ensure consistent mapping
                const newExisting = new Set();
                for (let r=1; r<rowsForDownload.length; r++) {
                    const row = rowsForDownload[r];
                    const pair = (pairIdx !== null && row[pairIdx]) ? row[pairIdx].trim() : '';
                    const word = (wordIdx !== null && row[wordIdx]) ? row[wordIdx].trim() : '';
                    const generated = generateCardID(pair || word || 'CARD', word || '', newExisting);
                    row.push(generated);
                }
            } else {
                // csv had CardID col but some rows were empty; fill empty ones using our earlier generated ids
                const cardIdIndex = cardIdIdx;
                // Build list of generated IDs in same order as cards building earlier: we used existingIDs and appended generated IDs
                // To keep it simple: iterate rows and if empty create new one
                const newExisting = new Set();
                // add existing ones
                for (let r=1; r<rowsForDownload.length; r++) {
                    const val = (rowsForDownload[r][cardIdIndex] || '').toString().trim();
                    if (val) newExisting.add(val);
                }
                for (let r=1; r<rowsForDownload.length; r++) {
                    if (!(rowsForDownload[r][cardIdIndex] || '').toString().trim()) {
                        const pair = (pairIdx !== null && rowsForDownload[r][pairIdx]) ? rowsForDownload[r][pairIdx].trim() : '';
                        const word = (wordIdx !== null && rowsForDownload[r][wordIdx]) ? rowsForDownload[r][wordIdx].trim() : '';
                        const generated = generateCardID(pair || word || 'CARD', word || '', newExisting);
                        rowsForDownload[r][cardIdIndex] = generated;
                    }
                }
            }
            // store updated CSV content for download
            window.__updatedCsvString = buildCSVString(rowsForDownload[0], rowsForDownload.slice(1));
            document.getElementById('download-updated-csv').style.display = 'inline-block';
            document.getElementById('migration-note').textContent = 'New CardIDs were generated for missing rows — you can download the CSV with CardIDs and replace the file.';
        } else {
            // No changes needed
            document.getElementById('download-updated-csv').style.display = 'none';
            document.getElementById('migration-note').textContent = csvHadCardIDs ? 'CSV includes CardID column.' : '';
        }
    }

    // ---------- Firestore migration & loading ----------
    // load user cardReviews, but be smart: accept docs keyed by CardID OR numeric index.
    // If numeric docs are present, and matching CardID for the index exists, copy to the new CardID doc (preserve existing destination if non-empty).
    async function loadUserDataAndMigrate() {
        const reviewsSnap = await db.collection(`users/${uid}/cardReviews`).get();
        cardData = {};
        const docs = [];
        reviewsSnap.forEach(doc => docs.push({ id: doc.id, data: doc.data() }));
        // First pass: store direct matches by CardID
        const cardIdToIndex = {};
        for (let i=0;i<cards.length;i++) cardIdToIndex[cards[i].id] = i;
        for (const d of docs) {
            if (cardIdToIndex[d.id] !== undefined) {
                // this doc id is already a CardID -> use it directly
                cardData[d.id] = d.data;
            }
        }
        // Second pass: handle numeric-keyed docs from legacy format -> migrate if necessary
        for (const d of docs) {
            if (!/^[0-9]+$/.test(d.id)) continue; // not numeric
            const numIdx = parseInt(d.id);
            if (numIdx >= 0 && numIdx < cards.length) {
                const destCardID = cards[numIdx].id;
                // if we already have dest data from the new CardID doc, skip migrating
                if (!cardData[destCardID]) {
                    // copy data to new CardID doc
                    const destRef = db.collection(`users/${uid}/cardReviews`).doc(destCardID);
                    try {
                        await destRef.set(d.data);
                        cardData[destCardID] = d.data;
                        // NOTE: we do NOT delete the old numeric doc automatically to be safe.
                        // If you want to remove numeric docs after verification, I can add a cleanup routine.
                    } catch (e) {
                        console.error('Error migrating doc', d.id, '->', destCardID, e);
                    }
                } else {
                    // dest already exists; skip
                }
            }
        }

        // Now load settings doc (unchanged location)
        const settingsRef = db.doc(`users/${uid}`);
        const settingsSnap = await settingsRef.get();
        if (settingsSnap.exists) {
            userSettings = settingsSnap.data();
        } else {
            userSettings = {
                dailyNewLimit: 10,
                newCardsToday: 0,
                reviewsToday: 0,
                lastNewDate: ''
            };
            await settingsRef.set(userSettings);
        }
        const todayStr = new Date().toDateString();
        if (userSettings.lastNewDate !== todayStr) {
            userSettings.newCardsToday = 0;
            userSettings.reviewsToday = 0;
            userSettings.lastNewDate = todayStr;
            await settingsRef.update({
                newCardsToday: 0,
                reviewsToday: 0,
                lastNewDate: todayStr
            });
        }
    }

    // ---------- SRS handling and UI (modified to use CardID) ----------
    function getNow() { return new Date(); }

    // returns next card object: { index, card, isNew }
    function getNextCard() {
        const now = getNow();
        // collect due candidates (document keys in cardData keyed by CardID)
        let dueCandidates = [];
        for (let i = 0; i < cards.length; i++) {
            const c = cards[i];
            const review = cardData[c.id];
            if (review && review.due && review.due.toDate && review.due.toDate() <= now) {
                dueCandidates.push({ index: i, card: c, review: review, dueTime: review.due.toDate().getTime() });
            }
        }
        if (dueCandidates.length > 0) {
            dueCandidates.sort((a,b)=>a.dueTime - b.dueTime);
            return { index: dueCandidates[0].index, card: dueCandidates[0].card, data: dueCandidates[0].review };
        }
        // show new if allowed
        if ((userSettings.newCardsToday || 0) < (userSettings.dailyNewLimit || 10)) {
            const unseen = [];
            for (let i=0;i<cards.length;i++) {
                if (!cardData[cards[i].id]) unseen.push(i);
            }
            if (unseen.length > 0) {
                const pick = unseen[Math.floor(Math.random()*unseen.length)];
                return { index: pick, card: cards[pick], isNew: true };
            }
        }
        return null;
    }

    function showCard(cardObj) {
        if (!cardObj) { showStats(); return; }
        currentCard = cardObj;
        const index = cardObj.index;
        const card = cards[index];
        const back = card.back;
        const pair = card.pair;
        const scale = (pair && scales[pair]) ? scales[pair] : [];
        const scaleIndex = scale.indexOf(back);
        const lower = scaleIndex > 0 ? scale[scaleIndex-1] : '';
        const higher = scaleIndex < scale.length-1 ? scale[scaleIndex+1] : '';
        document.getElementById('lower-neighbor-box').textContent = lower;
        document.getElementById('higher-neighbor-box').textContent = higher;
        document.getElementById('cloze-display').textContent = card.front;
        document.getElementById('answer-box').textContent = '';
        document.getElementById('card-num').textContent = `${index+1} / ${cards.length}`;
        isFlipped = false;
        // show controls
        document.getElementById('flashcard').style.display = 'block';
        document.getElementById('buttons').style.display = 'flex';
        document.getElementById('flipBtn').style.display = 'inline-block';
        document.getElementById('flipBtn').textContent = 'Show Answer';
        document.getElementById('incorrectBtn').style.display = 'none';
        document.getElementById('correctBtn').style.display = 'none';
    }

    function flip() {
        if (!currentCard || isFlipped) return;
        const index = currentCard.index;
        const back = cards[index].back;
        document.getElementById('answer-box').textContent = back;
        isFlipped = true;
        document.getElementById('flipBtn').style.display = 'none';
        document.getElementById('incorrectBtn').style.display = 'inline-block';
        document.getElementById('correctBtn').style.display = 'inline-block';
    }

    async function rate(correct) {
        if (!currentCard || !isFlipped) return;
        const index = currentCard.index;
        const card = cards[index];
        const cardKey = card.id;
        const oldData = cardData[cardKey] || { reps: 0, ef: 2.5, interval: 0 };
        const quality = correct ? 5 : 0;
        let newReps = oldData.reps || 0;
        let newEf = oldData.ef || 2.5;
        let newInterval = oldData.interval || 0;
        if (quality < 3) {
            newReps = 0;
            newInterval = 1;
            newEf = Math.max(1.3, (newEf - 0.20));
        } else {
            newReps = (oldData.reps || 0) + 1;
            if (newReps === 1) newInterval = 1;
            else if (newReps === 2) newInterval = 6;
            else newInterval = Math.max(1, Math.round((oldData.interval || 1) * (oldData.ef || 2.5)));
            const delta = 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02);
            newEf = (oldData.ef || 2.5) + delta;
            newEf = Math.max(1.3, newEf);
        }
        const now = new Date();
        const dueTime = now.getTime() + newInterval * 86400000;
        const newDue = firebase.firestore.Timestamp.fromDate(new Date(dueTime));
        const newData = {
            reps: newReps,
            ef: parseFloat(newEf.toFixed(2)),
            interval: newInterval,
            due: newDue
        };
        // store under cardKey
        const reviewRef = db.collection(`users/${uid}/cardReviews`).doc(cardKey);
        await reviewRef.set(newData);
        cardData[cardKey] = newData;
        // increment reviewsToday
        userSettings.reviewsToday = (userSettings.reviewsToday || 0) + 1;
        await db.doc(`users/${uid}`).update({ reviewsToday: userSettings.reviewsToday });
        // next
        await showNextCard();
    }

    async function showNextCard() {
        const next = getNextCard();
        if (!next) { showStats(); return; }
        if (next.isNew) {
            // initialize review doc under card.id if not present
            const cardKey = next.card.id;
            const initial = { reps: 0, ef: 2.5, interval: 0, due: firebase.firestore.Timestamp.now() };
            const existing = await db.collection(`users/${uid}/cardReviews`).doc(cardKey).get();
            if (!existing.exists) {
                await db.collection(`users/${uid}/cardReviews`).doc(cardKey).set(initial);
                cardData[cardKey] = initial;
            } else {
                cardData[cardKey] = existing.data();
            }
            userSettings.newCardsToday = (userSettings.newCardsToday || 0) + 1;
            await db.doc(`users/${uid}`).update({ newCardsToday: userSettings.newCardsToday });
            showCard({ index: next.index, data: cardData[cardKey] });
        } else {
            showCard({ index: next.index, data: next.data });
        }
        updateProgress();
    }

    function updateProgress() {
        const now = getNow();
        let dueCount = 0;
        for (let i=0;i<cards.length;i++) {
            const c = cards[i];
            const d = cardData[c.id];
            if (d && d.due && d.due.toDate && d.due.toDate() <= now) dueCount++;
        }
        const newAvailable = Math.max(0, (userSettings.dailyNewLimit || 10) - (userSettings.newCardsToday || 0));
        const learned = Object.keys(cardData).length;
        document.getElementById('progress').textContent = `${dueCount} pendientes | ${newAvailable} nuevas | ${learned}/${cards.length}`;
    }

    function showStats() {
        const learned = Object.keys(cardData).length;
        const total = cards.length;
        const newToday = userSettings.newCardsToday || 0;
        const reviewsToday = userSettings.reviewsToday || 0;
        const limit = userSettings.dailyNewLimit || 10;
        let statsText = '¡Felicitaciones! Estás al día con tus tarjetas.\n\n';
        statsText += `Aprendidas: ${learned} / ${total}\n`;
        statsText += `Nuevas hoy: ${newToday} / ${limit}\n`;
        statsText += `Revisadas hoy: ${reviewsToday}\n`;
        document.getElementById('ascii-stats').textContent = statsText;
        document.getElementById('ascii-stats').style.display = 'block';
        document.getElementById('flashcard').style.display = 'none';
        document.getElementById('buttons').style.display = 'none';
        document.getElementById('progress').textContent = '';
    }

    async function saveSettings() {
        if (!uid) return;
        const limit = parseInt(document.getElementById('daily-limit').value) || 10;
        userSettings.dailyNewLimit = limit;
        const settingsRef = db.doc(`users/${uid}`);
        await settingsRef.set(userSettings, { merge: true });
    }

    // ---------- Auth flows (unchanged) ----------
    function login() {
        const emailEl = document.getElementById('email');
        const passwordEl = document.getElementById('password');
        const errorEl = document.getElementById('error');
        const email = emailEl.value.trim();
        const password = passwordEl.value;
        if (!email || !password) {
            errorEl.textContent = 'Por favor, ingresa email y contraseña.';
            return;
        }
        errorEl.textContent = '';
        auth.signInWithEmailAndPassword(email, password).catch((error) => {
            let msg = 'Error de inicio de sesión: ';
            switch (error.code) {
                case 'auth/user-not-found': msg += 'Usuario no encontrado.'; break;
                case 'auth/wrong-password': msg += 'Contraseña incorrecta.'; break;
                case 'auth/invalid-email': msg += 'Email inválido.'; break;
                default: msg += error.message;
            }
            errorEl.textContent = msg;
        });
    }

    function signup() {
        const emailEl = document.getElementById('email');
        const passwordEl = document.getElementById('password');
        const errorEl = document.getElementById('error');
        const email = emailEl.value.trim();
        const password = passwordEl.value;
        if (!email || !password || password.length < 6) {
            errorEl.textContent = 'Email y contraseña (mín. 6 chars) requeridos.';
            return;
        }
        errorEl.textContent = '';
        auth.createUserWithEmailAndPassword(email, password).catch((error) => {
            let msg = 'Error al registrarse: ';
            switch (error.code) {
                case 'auth/email-already-in-use': msg += 'Email ya registrado.'; break;
                case 'auth/weak-password': msg += 'Contraseña débil.'; break;
                case 'auth/invalid-email': msg += 'Email inválido.'; break;
                default: msg += error.message;
            }
            errorEl.textContent = msg;
        });
    }

    // When user logs in, load CSV first, then perform migration and show cards
    auth.onAuthStateChanged(async (user) => {
        const loginForm = document.getElementById('login-form');
        const flashcard = document.getElementById('flashcard');
        const buttons = document.getElementById('buttons');
        const rate = document.getElementById('rate');
        const controls = document.getElementById('controls-footer');
        const asciiStats = document.getElementById('ascii-stats');
        const progress = document.getElementById('progress');
        const errorEl = document.getElementById('error');

        if (user) {
            uid = user.uid;
            loginForm.style.display = 'none';
            flashcard.style.display = 'block';
            buttons.style.display = 'flex';
            rate.style.display = 'flex';
            controls.style.display = 'block';
            asciiStats.style.display = 'none';
            errorEl.textContent = '';
            try {
                await loadCSVAndBuild();              // load CSV -> build cards, maybe generate ids
                await loadUserDataAndMigrate();      // load user data and migrate numeric keys
                document.getElementById('daily-limit').value = userSettings.dailyNewLimit || 10;
                await showNextCard();
            } catch (e) {
                console.error('Error loading data:', e);
                progress.textContent = 'Error al cargar datos: ' + (e.message || e);
            }
        } else {
            uid = null;
            cardData = {};
            userSettings = {};
            currentCard = null;
            isFlipped = false;
            loginForm.style.display = 'block';
            flashcard.style.display = 'none';
            buttons.style.display = 'none';
            rate.style.display = 'none';
            controls.style.display = 'none';
            asciiStats.style.display = 'none';
            progress.textContent = '';
            errorEl.textContent = '';
        }
    });

    // Provide a way to download the updated CSV (with CardIDs) if we generated missing ones
    function downloadUpdatedCSV() {
        if (!window.__updatedCsvString) return;
        const blob = new Blob([window.__updatedCsvString], {type: 'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'flashcard-data-with-CardIDs.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    </script>
</body>
</html>
