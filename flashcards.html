<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Antonimo Flashcards</title>
    <style>
        /* Base Styles */
        body {
            font-family: 'Inter', Arial, sans-serif;
            text-align: center;
            margin: 20px;
            position: relative;
            min-height: 100vh;
            background-color: white;
            overflow-x: hidden;
            color: #333;
        }
        
        /* Utility for retro font style */
        .retro-font {
            font-family: monospace;
            font-weight: bold;
        }

        /* Responsive Background Logo (Pelican) */
        .logo-bg {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 600px;
            opacity: 0.25;
            z-index: -1;
            pointer-events: none;
            /* Placeholder for the ASCII Pelican graphic */
            content: " "; 
        }
        @media (max-width: 800px) {
            .logo-bg {
                width: 80vw;
                opacity: 0.3;
            }
        }

        /* Flashcard Container */
        #flashcard {
            max-width: 600px;
            margin: 40px auto;
            padding: 20px;
            border: 3px solid #6366f1; /* Indigo border */
            border-radius: 12px;
            background: #f8f8ff; /* Light, clean background */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }
        #flashcard:hover {
            transform: translateY(-2px);
        }

        /* Card Content */
        #front, #back {
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 15px 0;
        }
        .main-word {
            font-size: 2.5em;
            font-weight: 700;
            color: #1e40af; /* Darker blue for focus */
            margin-bottom: 10px;
        }
        .hint { 
            font-size: 0.95em; 
            color: #4b5563; 
            font-style: italic;
            padding: 5px 10px;
            border-left: 3px solid #9ca3af;
            background-color: #f3f4f6;
            border-radius: 4px;
        }
        .below-hint { margin-top: 20px; }

        /* Back of Card Details */
        #back-details {
            text-align: left;
            padding-top: 20px;
            border-top: 1px dashed #ccc;
            width: 100%;
        }
        .back-detail-item {
            margin-bottom: 8px;
            font-size: 1em;
            color: #444;
        }
        .back-detail-item strong {
            color: #6366f1;
            font-weight: 600;
        }
        .intermediary-list {
            margin-top: 5px;
            padding-left: 20px;
            list-style: disc;
        }
        .intermediary-list li {
            margin: 4px 0;
        }

        /* UI Elements */
        #card-num, #learned-status { 
            font-size: 1.1em; 
            margin-bottom: 10px;
            color: #10b981; /* Green for status */
            font-weight: 600;
        }
        #learned-count {
            color: #ef4444; /* Red for emphasis */
            font-weight: bold;
        }

        /* Buttons */
        button {
            padding: 12px 25px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px #9ca3af;
        }
        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #9ca3af;
        }

        #flipBtn {
            background-color: #6366f1;
            color: white;
            box-shadow: 0 4px #4f46e5;
        }
        #flipBtn:hover { background-color: #4f46e5; }
        #flipBtn:active { box-shadow: 0 2px #4f46e5; }

        .rate-btn {
            color: white;
        }
        .rate-btn.easy {
            background-color: #10b981; /* Green */
            box-shadow: 0 4px #059669;
        }
        .rate-btn.easy:hover { background-color: #059669; }
        .rate-btn.easy:active { box-shadow: 0 2px #059669; }
        .rate-btn.hard {
            background-color: #f59e0b; /* Amber */
            box-shadow: 0 4px #d97706;
        }
        .rate-btn.hard:hover { background-color: #d97706; }
        .rate-btn.hard:active { box-shadow: 0 2px #d97706; }
    </style>
</head>
<body>
    
    <div id="loading-message" class="retro-font" style="font-size: 1.5em; margin-top: 100px;">
        LOADING LEXICAL DATA... 
    </div>

    <div id="flashcard" style="display:none;">
        <div id="card-num" class="retro-font"></div>
        <div id="learned-status">Learned: <span id="learned-count">0</span> / 0</div>

        <div id="front"></div>
        <div id="back"></div>

        <button id="flipBtn" onclick="flip()">REVEAL</button>

        <div id="rate" style="display:none;">
            <button class="rate-btn hard" onclick="rate(false)">HARD (Repeat Soon)</button>
            <button class="rate-btn easy" onclick="rate(true)">EASY (Next Level)</button>
        </div>
    </div>

    <script>
        // --- DATA STRUCTURES ---
        let cards = [];
        let srsData = [];
        let activeIds = [];
        let currentId = 0;
        let flipped = false;

        const LOCAL_STORAGE_KEY_SRS = 'antonimo_srs_data';
        const LOCAL_STORAGE_KEY_ACTIVE = 'antonimo_active_ids';

        // --- LOCAL STORAGE FUNCTIONS (Persistence) ---

        /** Saves the current SRS state (streaks and active card list) to localStorage. */
        function save() {
            localStorage.setItem(LOCAL_STORAGE_KEY_SRS, JSON.stringify(srsData));
            localStorage.setItem(LOCAL_STORAGE_KEY_ACTIVE, JSON.stringify(activeIds));
        }

        /** Loads SRS state from localStorage or initializes it if no data is found. */
        function load() {
            const savedSrsData = localStorage.getItem(LOCAL_STORAGE_KEY_SRS);
            if (savedSrsData) {
                // If data exists, load it
                srsData = JSON.parse(savedSrsData);
                activeIds = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY_ACTIVE));
            } else {
                // If no data, initialize all cards to streak 0 and start with the first card.
                srsData = cards.map(() => ({ streak: 0, learnedTime: 0 }));
                activeIds = [0];
            }
            
            // Safety check: ensure srsData size matches the new cards array size after CSV load
            while (srsData.length < cards.length) {
                srsData.push({ streak: 0, learnedTime: 0 });
            }
            
            // Set currentId to a random active card, or the first one if only one exists
            if (activeIds.length > 0) {
                currentId = activeIds[Math.floor(Math.random() * activeIds.length)];
            } else if (cards.length > 0) {
                // Should only happen if all were previously learned, but we'll restart learning if activeIds is empty
                currentId = 0;
                activeIds = [0];
            }
        }

        // --- DATA LOADING (CSV) ---

        /** Fetches and parses the CSV data file. */
        async function loadCSVData() {
            try {
                const response = await fetch('game-data.csv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const rows = text.trim().split('\n').slice(1); // Skip header row
                
                cards = rows.map((row, index) => {
                    // Simple CSV parsing: split by comma, but be aware of semicolon for intermediary words
                    // Columns: Pair (Low-High),Intermediaries,Part of Speech,Hint,Gradability Type
                    const columns = row.split(',').map(c => c.trim()); 
                    
                    const [lowHighPair, intermediaries, pos, hint, gradability] = columns;
                    
                    const [lower, upper] = lowHighPair.split('-').map(w => w.trim());
                    
                    // Intermediaries are separated by semicolon (e.g., "murmurar;hablar")
                    const middle = intermediaries.split(';').map(w => w.trim()).filter(w => w.length > 0);
                    
                    return {
                        id: index,
                        upper: upper,
                        lower: lower,
                        middle: middle, // Array of intermediary words
                        hint: hint,
                        pos: pos,
                        gradability: gradability
                    };
                }).filter(card => card.upper && card.lower && card.middle.length > 0); // Only keep valid cards

                console.log(`Loaded ${cards.length} cards successfully from CSV.`);
                document.getElementById('loading-message').style.display = 'none';
                document.getElementById('flashcard').style.display = 'block';
                initializeGame();

            } catch (error) {
                console.error("Failed to load CSV data:", error);
                document.getElementById('loading-message').textContent = 'ERROR: Could not load game data.';
            }
        }

        // --- GAME LOGIC ---

        /** Initializes the game after data is loaded. */
        function initializeGame() {
            if (cards.length === 0) {
                document.getElementById('loading-message').textContent = 'No valid card data available.';
                return;
            }
            load();
            updateLearned();
            showCard();
        }

        /** Updates the count of learned/total cards in the status bar. */
        function updateLearned() {
            const learnedCount = srsData.filter(data => data.learnedTime > 0).length;
            document.getElementById('learned-status').innerHTML = 
                `Learned: <span id="learned-count">${learnedCount}</span> / ${cards.length}`;
        }
        
        /** Renders the current card (front or back). */
        function showCard() {
            const card = cards[currentId];
            
            // Front content (always visible)
            let frontHtml = `<div class="main-word">${card.lower}</div>`;
            frontHtml += `<div class="hint above-hint">${card.hint}</div>`;
            
            // Back content (only visible when flipped)
            let backHtml = '';
            if (flipped) {
                backHtml += `<div id="back-details">`;
                backHtml += `<div class="back-detail-item"><strong>Gradability Type:</strong> ${card.gradability}</div>`;
                backHtml += `<div class="back-detail-item"><strong>Part of Speech:</strong> ${card.pos}</div>`;
                backHtml += `<div class="back-detail-item"><strong>Scale (Low to High):</strong>`;
                backHtml += `<ol class="intermediary-list">`;
                backHtml += `<li>${card.lower} (Low)</li>`;
                card.middle.forEach(word => {
                    backHtml += `<li>${word}</li>`;
                });
                backHtml += `<li>${card.upper} (High)</li>`;
                backHtml += `</ol></div>`;
                backHtml += `</div>`;
            }

            document.getElementById('card-num').textContent = `Card ${currentId + 1}`;
            document.getElementById('front').innerHTML = frontHtml;
            document.getElementById('back').innerHTML = flipped ? backHtml : '';
            
            document.getElementById('flipBtn').style.display = flipped ? 'none' : 'block';
            document.getElementById('rate').style.display = flipped ? 'block' : 'none';
        }

        /** Flips the card to show the back. */
        function flip() {
            flipped = true;
            showCard();
        }

        /** Handles user rating, updates streak, saves state, and loads the next card. */
        function rate(correct) {
            if (correct) {
                // Increase streak
                srsData[currentId].streak++;
                
                // If streak reaches 3, mark as learned and remove from active list
                if (srsData[currentId].streak === 3) {
                    srsData[currentId].learnedTime = Date.now();
                    activeIds = activeIds.filter(id => id !== currentId);
                }
            } else {
                // If incorrect, reset streak to 0
                srsData[currentId].streak = 0;
                
                // Ensure the card is back in the active list if it was mistakenly removed
                if (!activeIds.includes(currentId)) {
                    activeIds.push(currentId);
                }
            }
            
            save();
            updateLearned();
            flipped = false;
            
            if (activeIds.length === 0) {
                // Use a non-blocking message box instead of alert
                document.getElementById('flashcard').innerHTML = 
                    `<h2 style="color: #10b981;">CONGRATULATIONS!</h2><p>You have learned all available cards. Press F5 to reset your progress.</p>`;
                return;
            }

            // Select the next card (simple random selection from active list)
            currentId = activeIds[Math.floor(Math.random() * activeIds.length)];
            showCard();
        }
        
        // --- STARTUP ---
        loadCSVData(); // Start the process by loading data
    </script>
</body>
</html>
